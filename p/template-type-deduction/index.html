<!doctype html><html lang=en-au dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="First, let&rsquo;s distinguish different cases of const 1 2 3 4 5 6 7 8 // Variables const int x; // top-level const // References const int& r1 = x; // low-level const int& const r2 = x; // this syntax doesn't exist // Pointers const int* p1 = &amp;x; // low-level const int* const p2 = &amp;x; // top-level const For top-level const, it indicates that the variable itself cannot be modified. As the name suggests, &ldquo;top-level&rdquo; refers to the topmost layer, which is the variable itself.\nFor low-level const, it indicates that the space pointed to by the reference/pointer cannot be modified.\n"><title>Template Type Deduction</title>
<link rel=canonical href=https://www.dzx1025.com/p/template-type-deduction/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="Template Type Deduction"><meta property='og:description' content="First, let&rsquo;s distinguish different cases of const 1 2 3 4 5 6 7 8 // Variables const int x; // top-level const // References const int& r1 = x; // low-level const int& const r2 = x; // this syntax doesn't exist // Pointers const int* p1 = &amp;x; // low-level const int* const p2 = &amp;x; // top-level const For top-level const, it indicates that the variable itself cannot be modified. As the name suggests, &ldquo;top-level&rdquo; refers to the topmost layer, which is the variable itself.\nFor low-level const, it indicates that the space pointed to by the reference/pointer cannot be modified.\n"><meta property='og:url' content='https://www.dzx1025.com/p/template-type-deduction/'><meta property='og:site_name' content><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='c/c++'><meta property='article:published_time' content='2023-03-12T12:18:59+00:00'><meta property='article:modified_time' content='2023-03-12T12:18:59+00:00'><meta name=twitter:title content="Template Type Deduction"><meta name=twitter:description content="First, let&rsquo;s distinguish different cases of const 1 2 3 4 5 6 7 8 // Variables const int x; // top-level const // References const int& r1 = x; // low-level const int& const r2 = x; // this syntax doesn't exist // Pointers const int* p1 = &amp;x; // low-level const int* const p2 = &amp;x; // top-level const For top-level const, it indicates that the variable itself cannot be modified. As the name suggests, &ldquo;top-level&rdquo; refers to the topmost layer, which is the variable itself.\nFor low-level const, it indicates that the space pointed to by the reference/pointer cannot be modified.\n"><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_5ae282b1e26cbbe.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/></a></h1><h2 class=site-description>Software | Music | Minimalism | UX | Libertarianism | Video Game | Anime</h2></div></header><ol class=menu-social><li><a href=https://github.com/Dzx1025 target=_blank title=GitHub rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-github"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/zekeding/ target=_blank title=LinkedIn rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-linkedin"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4m0 2a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2z"/><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 00-4 0"/></svg></a></li><li><a href='https://www.instagram.com/zexud?igsh=Y3N5eHVqaWs1Z2Mz&amp;utm_source=qr' target=_blank title=Instagram rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-instagram"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4m0 4a4 4 0 014-4h8a4 4 0 014 4v8a4 4 0 01-4 4H8a4 4 0 01-4-4z"/><path d="M12 12m-3 0a3 3 0 106 0 3 3 0 10-6 0"/><path d="M16.5 7.5v.01"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/blogroll/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Blogroll</span></a></li><li class=menu-bottom-section><ol class=menu></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#first-lets-distinguish-different-cases-of-const>First, let&rsquo;s distinguish different cases of const</a></li><li><a href=#type-deduction>Type Deduction</a><ol><li><a href=#_paramtype_-is-a-referencepointer-but-not-a-universal-reference><em>ParamType</em> is a Reference/Pointer, but not a Universal Reference</a></li><li><a href=#_paramtype_-is-a-universal-reference><em>ParamType</em> is a Universal Reference</a></li><li><a href=#_paramtype_-is-neither-a-pointerreference-nor-a-universal-reference><em>ParamType</em> is Neither a Pointer/Reference Nor a Universal Reference</a></li><li><a href=#array-function-decay-to-pointer>Array Function Decay to Pointer</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/notes/>Notes</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/template-type-deduction/>Template Type Deduction</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 12, 2023</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>6 minute read</time></div></footer></div></header><section class=article-content><h2 id=first-lets-distinguish-different-cases-of-const>First, let&rsquo;s distinguish different cases of const</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Variables
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>       <span class=c1>// top-level const
</span></span></span><span class=line><span class=cl><span class=c1>// References
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>r1</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// low-level const
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=o>&amp;</span> <span class=k>const</span> <span class=n>r2</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// this syntax doesn&#39;t exist
</span></span></span><span class=line><span class=cl><span class=c1>// Pointers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span><span class=o>*</span> <span class=n>p1</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span> <span class=c1>// low-level const
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=o>*</span> <span class=k>const</span> <span class=n>p2</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span> <span class=c1>// top-level const
</span></span></span></code></pre></td></tr></table></div></div><p>For top-level const, it indicates that the variable <strong>itself</strong> cannot be modified. As the name suggests, &ldquo;top-level&rdquo; refers to the topmost layer, which is the variable itself.</p><p>For low-level const, it indicates that the space <strong>pointed to</strong> by the reference/pointer cannot be modified.</p><p>Why can&rsquo;t references be declared with top-level <code>const</code>? This is because <strong>all references are inherently top-level <code>const</code></strong> - once a reference is initialized, it cannot be changed to reference another object. Since references already have the top-level <code>const</code> property, there&rsquo;s no need for us to explicitly declare it. As we can see, the most common references/pointers we encounter are low-level <code>const</code>, meaning they modify the immutability of the variables they point to.</p><p>With this understanding, let&rsquo;s look at template type deduction.</p><h2 id=type-deduction>Type Deduction</h2><p>First, let&rsquo;s introduce common terminology. In template function calls using <code>f(expr)</code>, we have arguments and parameters. Here, we&rsquo;ll mainly study the parameters and the typename&rsquo;s value type, which are <code>T</code> and <code>ParamType</code>.</p><p>C++ has three forms of <code>ParamType</code> declarations, representing three different deduction rules:</p><h3 id=_paramtype_-is-a-referencepointer-but-not-a-universal-reference><em>ParamType</em> is a Reference/Pointer, but not a Universal Reference</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>param</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// For pointer ParamType:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>param</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>First, <strong>if the type of <code>expr</code> is a reference, the reference part is ignored</strong>, so <code>int&</code> and <code>int</code> should yield the same deduction result. Since <code>ParamType</code> already specifies that the function parameter is a reference, when both <code>expr</code> and <code>paramtype</code> are references, <code>expr</code>&rsquo;s reference part is ignored.</p><p>The same principle applies when both are pointers - <code>int*</code> and <code>int</code> are treated equally because <code>ParamType</code> already indicates that this template wants to use a reference/pointer type parameter.</p><p>Note that when <code>ParamType</code> is a reference type and <code>expr</code> is a pointer type, the pointer part isn&rsquo;t ignored - <code>T</code>&rsquo;s type will match <code>expr</code>, as shown below. However, in normal circumstances, why would you pass a pointer to a reference? Conversely, when <code>ParamType</code> is a pointer and <code>expr</code> is a reference type, calling <code>f(expr)</code> requires passing the address of the reference to match, which is essentially the same as passing a variable&rsquo;s address.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=o>=</span><span class=mi>27</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>cx</span><span class=o>=</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>rx</span><span class=o>=</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=o>*</span> <span class=n>p1</span><span class=o>=&amp;</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=k>const</span> <span class=n>p2</span><span class=o>=&amp;</span><span class=n>x</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>  <span class=c1>// T-&gt; int           f(int&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>cx</span><span class=p>);</span> <span class=c1>// T-&gt; const int     f(const int&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>rx</span><span class=p>);</span> <span class=c1>// T-&gt; const int     f(const int&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span> <span class=c1>// T-&gt; const int *   f(const int *&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span> <span class=c1>// T-&gt; int *const    f(int *const &amp;)
</span></span></span></code></pre></td></tr></table></div></div><p>For callers, when passing a <code>const</code> object to a reference parameter, they expect the object to maintain its immutability. If the passed parameter cannot modify the content it points to, the template should obviously also protect that space from modification.</p><p>Therefore, the parameter will also be reference-to-const. This makes it safe to pass a const object to a template with a <code>T&</code> type parameter: the object&rsquo;s constness is preserved as part of <code>T</code>.</p><p>We can see that <code>T</code> preserves both top-level and low-level const attributes from the argument <code>expr</code>, while <code>ParamType</code> simply adds a <code>&</code> after the deduced <code>typename T</code>, becoming <code>const T&</code>.</p><h3 id=_paramtype_-is-a-universal-reference><em>ParamType</em> is a Universal Reference</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>param</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>In this case, <code>ParamType</code> is called a universal reference. For universal references, we must discuss two situations based on <code>expr</code>&rsquo;s <strong>value category</strong>:</p><ol><li><p>When <code>expr</code> is an lvalue: Both <code>T</code> and <code>ParamType</code> are deduced as lvalue references. This is <strong>the only case in template type deduction where <code>T</code> is deduced as a reference</strong>.</p><p>In this case, <code>ParamType</code>&rsquo;s final result is actually consistent with scenario 1&rsquo;s deduction result. The only difference is that in scenario 1, <code>&</code> is added to the parameter after <code>T</code> is deduced as a base type, while for universal references, <code>&</code> is added when deducing <code>T</code> - only <code>T</code> differs.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=o>=</span><span class=mi>27</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>cx</span><span class=o>=</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>rx</span><span class=o>=</span><span class=n>cx</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>           <span class=c1>//x is lvalue    T-&gt; int&amp;,        f(int&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>cx</span><span class=p>);</span>          <span class=c1>//cx is lvalue   T-&gt; const int&amp;    f(const int&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>rx</span><span class=p>);</span>          <span class=c1>//rx is lvalue   T-&gt; const int&amp;    f(const int&amp;)
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>When <code>expr</code> is an rvalue: Use normal deduction rules (same as <strong>scenario 1</strong>)</p><p>Here, <code>T</code> will be the &ldquo;base&rdquo; type, while <code>ParamType</code> will be an rvalue reference, i.e., <code>T&&</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=mi>27</span><span class=p>);</span>              <span class=c1>// T-&gt; int      f(int&amp;&amp;)
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=_paramtype_-is-neither-a-pointerreference-nor-a-universal-reference><em>ParamType</em> is Neither a Pointer/Reference Nor a Universal Reference</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span> <span class=n>param</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>This situation is similar to pass-by-value handling. This means the template actually generates a complete new object copy.</p><ol><li>As before, if <code>expr</code>&rsquo;s type is a reference, ignore the reference part</li><li>Unlike scenario 1, <code>expr</code>&rsquo;s <code>const</code> and <code>volatile</code> attributes are also ignored here, which is very reasonable because the original object&rsquo;s attributes shouldn&rsquo;t affect the copy&rsquo;s attributes - after all, the template is only responsible for passing types</li></ol><p>Therefore, the above <code>x cx rx</code> will all be deduced as <code>int</code></p><p>However, note that <code>const</code> is only ignored when passing by value to parameters. For reference-to-<code>const</code> and pointer-to-<code>const</code> parameters, besides themselves, they also contain the space they point to. What happens to this pointed space?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>ptr</span><span class=o>=</span><span class=s>&#34;Hello&#34;</span><span class=p>;</span>   <span class=c1>// ptr is a const pointer pointing to const object
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>x</span><span class=o>=</span><span class=mi>12</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>                          <span class=c1>// T-&gt; const char *
</span></span></span></code></pre></td></tr></table></div></div><p>In this case, only the <strong>top-level</strong> <code>const</code> of <code>expr</code> is ignored, while the <strong>low-level</strong> <code>const</code> is preserved. Therefore, when we call <code>f("hello")</code>, <code>T</code> is deduced as <code>const char *</code>. It&rsquo;s like we copied a pointer - the template is still responsible for ensuring that the data pointed to by two identical pointers cannot be modified.</p><h3 id=array-function-decay-to-pointer>Array Function Decay to Pointer</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span> <span class=n>param</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=n>name</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;J. P. Briggs&#34;</span><span class=p>;</span>     <span class=c1>// name&#39;s type is const char[13]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>  <span class=c1>// T-&gt; const char * i.e., f(const char*)
</span></span></span></code></pre></td></tr></table></div></div><p>But if we make a small change&mldr;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>param</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>  <span class=c1>// T-&gt; const char[13]  f(const char(&amp;)[13])
</span></span></span></code></pre></td></tr></table></div></div><p>This type includes the array&rsquo;s size. In this example, <code>T</code> is deduced as <code>const char[13]</code>, and the type of <code>f</code>&rsquo;s parameter (reference to this array) is <code>const char (&)[13]</code></p><p>But since you&rsquo;re writing in C++, it&rsquo;s recommended to use array instead&mldr;.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/c/c++/>C/C++</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=document.querySelector(".main-article");renderMathInElement(e,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/c-raii/><div class=article-details><h2 class=article-title>C++ RAII</h2></div></a></article><article><a href=/p/c-value-categories-and-semantics/><div class=article-details><h2 class=article-title>C++ Value Categories and Semantics</h2></div></a></article></div></div></aside><div class=disqus-container></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2024 -
2025</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>